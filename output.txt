File: /Users/haruki/golang-mvcc/cmd/mvcc-simulator/main.go
package main

import (
	"fmt"
	"log"
	"sync"

	"github.com/Mahopanda/golang-mvcc/pkg/mvcc"
)

func main() {
	db := mvcc.NewDatabase()

	// Step 1: Simulate Transactions
	fmt.Println("=== Step 1: Simulate Transactions ===")
	tx1 := db.Begin()
	db.Write(tx1, "key1", "value1")
	fmt.Println("Transaction 1 wrote 'value1'.")

	tx2 := db.Begin()
	value, err := db.ReadWithIsolation(tx2, "key1", mvcc.ReadUncommitted)
	if err != nil {
		fmt.Printf("Transaction 2 failed to read: %v\n", err)
	} else {
		fmt.Printf("Transaction 2 read (Uncommitted): %s\n", value)
	}

	// Commit Transaction 1
	err = db.Commit(tx1)
	if err != nil {
		fmt.Printf("Failed to commit Transaction 1: %v\n", err)
	} else {
		fmt.Println("Transaction 1 committed.")
	}

	// Step 2: Read after commit with Read Committed isolation
	fmt.Println("=== Step 2: Read with Read Committed Isolation ===")
	tx3 := db.Begin()
	value, err = db.ReadWithIsolation(tx3, "key1", mvcc.ReadCommitted)
	if err != nil {
		fmt.Printf("Transaction 3 failed to read: %v\n", err)
	} else {
		fmt.Printf("Transaction 3 read (Committed): %s\n", value)
	}

	// Step 3: Perform Garbage Collection
	fmt.Println("=== Step 3: Garbage Collection ===")
	db.CleanupOldVersions()
	fmt.Println("Garbage collection completed.")

	// Step 4: Verify Garbage Collection
	record := db.GetData()["key1"]
	fmt.Printf("Number of versions after garbage collection: %d\n", len(record.GetVersions()))

	// Step 5: Simulate Concurrent Transactions
	fmt.Println("=== Step 4: Simulate Concurrent Transactions ===")
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		defer wg.Done()
		tx := db.Begin()
		db.Write(tx, "key1", "value2")
		db.Commit(tx)
		log.Println("Transaction 4 wrote 'value2' and committed.")
	}()

	go func() {
		defer wg.Done()
		tx := db.Begin()
		db.Write(tx, "key1", "value3")
		db.Commit(tx)
		log.Println("Transaction 5 wrote 'value3' and committed.")
	}()

	wg.Wait()

	// Verify Concurrent Transactions
	tx6 := db.Begin()
	value, err = db.ReadWithIsolation(tx6, "key1", mvcc.RepeatableRead)
	if err != nil {
		fmt.Printf("Transaction 6 failed to read: %v\n", err)
	} else {
		fmt.Printf("Transaction 6 read (RepeatableRead): %s\n", value)
	}

	fmt.Println("=== Program Completed ===")
}


File: /Users/haruki/golang-mvcc/export.go
package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
)

func export() {
	// 指定資料夾路徑
	folderPath := "/Users/haruki/golang-mvcc" // 請將此路徑更改為你要遍歷的資料夾

	// 輸出檔案名稱
	outputFileName := "output.txt"

	// 開啟或建立輸出檔案
	outputFile, err := os.Create(outputFileName)
	if err != nil {
		fmt.Printf("無法建立輸出檔案: %v\n", err)
		return
	}
	defer outputFile.Close()

	// 遍歷資料夾
	err = filepath.Walk(folderPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		// 檢查是否為 .go 檔案
		if !info.IsDir() && filepath.Ext(path) == ".go" {
			// 讀取檔案內容
			content, err := ioutil.ReadFile(path)
			if err != nil {
				return err
			}

			// 寫入路徑和內容到輸出檔案
			_, err = outputFile.WriteString(fmt.Sprintf("File: %s\n", path))
			if err != nil {
				return err
			}
			_, err = outputFile.WriteString(string(content) + "\n\n")
			if err != nil {
				return err
			}
		}
		return nil
	})

	if err != nil {
		fmt.Printf("遍歷資料夾時發生錯誤: %v\n", err)
	} else {
		fmt.Printf("所有 .go 檔案已成功輸出到 %s\n", outputFileName)
	}
}

func main() {
	export()
}


File: /Users/haruki/golang-mvcc/pkg/mvcc/database.go
// 資料庫邏輯
package mvcc

import (
	"errors"
	"sync"
)

// Database 定義MVCC數據庫
type Database struct {
	data      map[string]*Record
	currentTS int           // 全局時間戳
	mu        sync.RWMutex
}

// NewDatabase 創建新數據庫實例
func NewDatabase() *Database {
	return &Database{
		data: make(map[string]*Record),
	}
}

// Begin 開始新事務
func (db *Database) Begin() *Transaction {
	db.mu.Lock()
	defer db.mu.Unlock()
	
	db.currentTS++
	return &Transaction{
		ID:      db.currentTS,
		ReadTS:  db.currentTS,
		WriteTS: db.currentTS,
	}
}

// Write 寫入數據
func (db *Database) Write(tx *Transaction, key, value string) error {
	if tx == nil {
		return errors.New("invalid transaction")
	}

	db.mu.Lock()
	record, exists := db.data[key]
	if !exists {
		record = NewRecord()
		db.data[key] = record
	}
	db.mu.Unlock()

	return record.InsertVersion(value, tx.WriteTS, false)
}

// Commit 提交事務
func (db *Database) Commit(tx *Transaction) error {
	if tx == nil {
		return errors.New("invalid transaction")
	}

	db.mu.RLock()
	defer db.mu.RUnlock()

	for _, record := range db.data {
		if err := record.CommitVersion(tx.WriteTS); err != nil {
			return err
		}
	}
	return nil
}

// Read 讀取數據
func (db *Database) Read(tx *Transaction, key string) (string, error) {
	if tx == nil {
		return "", errors.New("invalid transaction")
	}

	db.mu.RLock()
	record, exists := db.data[key]
	if !exists {
		db.mu.RUnlock()
		return "", errors.New("key not found")
	}
	db.mu.RUnlock()

	version, err := record.GetVersion(tx.ReadTS)
	if err != nil {
		return "", err
	}
	return version.Value, nil
}

// CleanupOldVersions 執行垃圾回收
func (db *Database) CleanupOldVersions() {
	db.mu.RLock()
	records := make([]*Record, 0, len(db.data))
	for _, record := range db.data {
		records = append(records, record)
	}
	db.mu.RUnlock()

	for _, record := range records {
		record.CleanupVersions()
	}
}

// GetData returns the internal data map for testing purposes
func (db *Database) GetData() map[string]*Record {
	db.mu.RLock()
	defer db.mu.RUnlock()
	return db.data
}

// AdvanceTime advances the current timestamp
func (db *Database) AdvanceTime(amount int) {
	db.mu.Lock()
	defer db.mu.Unlock()
	db.currentTS += amount
}

// Rollback 回滾事務
func (db *Database) Rollback(tx *Transaction) error {
	if tx == nil {
		return errors.New("invalid transaction")
	}

	db.mu.RLock()
	defer db.mu.RUnlock()

	for _, record := range db.data {
		record.mu.Lock()
		newVersions := make([]*Version, 0)
		for _, v := range record.Versions {
			if v.Timestamp != tx.WriteTS {
				newVersions = append(newVersions, v)
			}
		}
		record.Versions = newVersions
		record.mu.Unlock()
	}
	return nil
}



File: /Users/haruki/golang-mvcc/pkg/mvcc/isolation.go
// 隔離級別邏輯
package mvcc

import "errors"

// IsolationLevel defines the types of transaction isolation levels.
type IsolationLevel int

const (
	ReadUncommitted IsolationLevel = iota
	ReadCommitted
	RepeatableRead
	Serializable
)

// ReadWithIsolation handles reading based on isolation levels.
func (db *Database) ReadWithIsolation(tx *Transaction, key string, level IsolationLevel) (string, error) {
	db.mu.RLock()
	record, exists := db.data[key]
	if !exists {
		db.mu.RUnlock()
		return "", errors.New("key not found")
	}
	db.mu.RUnlock()

	switch level {
	case ReadUncommitted:
		// 讀取最新版本，不管是否提交
		record.mu.RLock()
		defer record.mu.RUnlock()
		if len(record.Versions) == 0 {
			return "", errors.New("no versions available")
		}
		return record.Versions[len(record.Versions)-1].Value, nil

	case ReadCommitted:
		// 只讀取已提交的版本
		version, err := record.GetVersion(db.currentTS)
		if err != nil {
			return "", err
		}
		return version.Value, nil

	case RepeatableRead:
		// 使用事務開始時的時間戳讀取
		version, err := record.GetVersion(tx.ReadTS)
		if err != nil {
			return "", err
		}
		return version.Value, nil

	default:
		return "", errors.New("unsupported isolation level")
	}
}


File: /Users/haruki/golang-mvcc/pkg/mvcc/record.go
package mvcc

import (
	"errors"
	"sync"
)

// Version 定義數據版本
type Version struct {
	Value     string
	Timestamp int
	EndTS     int
	Committed bool
}

// Record 定義數據記錄
type Record struct {
	mu       sync.RWMutex
	Versions []*Version // 改為公開，方便測試
}

func NewRecord() *Record {
	return &Record{
		Versions: make([]*Version, 0),
	}
}

// InsertVersion 插入新版本
func (r *Record) InsertVersion(value string, ts int, committed bool) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	// 檢查時間戳衝突
	for _, v := range r.Versions {
		if v.Timestamp == ts {
			return errors.New("version timestamp conflict")
		}
	}

	// 為上一個版本設置結束時間戳
	if len(r.Versions) > 0 {
		r.Versions[len(r.Versions)-1].EndTS = ts
	}

	r.Versions = append(r.Versions, &Version{
		Value:     value,
		Timestamp: ts,
		EndTS:     0,
		Committed: committed,
	})
	return nil
}

// CommitVersion 提交指定時間戳的版本
func (r *Record) CommitVersion(ts int) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	for _, v := range r.Versions {
		if v.Timestamp == ts {
			v.Committed = true
			return nil
		}
	}
	return errors.New("version not found")
}

// GetVersion 獲取指定時間戳的版本
func (r *Record) GetVersion(ts int) (*Version, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	var latest *Version
	for _, v := range r.Versions {
		if v.Timestamp <= ts && v.Committed {
			if latest == nil || v.Timestamp > latest.Timestamp {
				latest = v
			}
		}
	}
	if latest == nil {
		return nil, errors.New("no valid version found")
	}
	return latest, nil
}

// CleanupVersions 清理舊版本
func (r *Record) CleanupVersions() {
	r.mu.Lock()
	defer r.mu.Unlock()

	if len(r.Versions) <= 1 {
		return
	}

	// 只保留最新的已提交版本
	var latest *Version
	for _, v := range r.Versions {
		if v.Committed {
			if latest == nil || v.Timestamp > latest.Timestamp {
				latest = v
			}
		}
	}

	if latest != nil {
		r.Versions = []*Version{latest}
	}
}



File: /Users/haruki/golang-mvcc/pkg/mvcc/serializable.go
package mvcc

import (
	"errors"
	"sync"
)

// SerializableLock represents a lock for a query range.
type SerializableLock struct {
	mu    sync.Mutex
	locks map[string]struct{}
}

// NewSerializableLock creates a new lock instance.
func NewSerializableLock() *SerializableLock {
	return &SerializableLock{locks: make(map[string]struct{})}
}

// LockRange locks a range for a transaction.
func (s *SerializableLock) LockRange(key string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	if _, exists := s.locks[key]; exists {
		return errors.New("range already locked")
	}
	s.locks[key] = struct{}{}
	return nil
}

// UnlockRange unlocks a range.
func (s *SerializableLock) UnlockRange(key string) {
	s.mu.Lock()
	defer s.mu.Unlock()
	delete(s.locks, key)
}

// GetVersions returns the versions of the record for testing purposes.
func (r *Record) GetVersions() []*Version {
	return r.Versions
}

func (r *Record) GetAllVersions() []*Version {
	r.mu.Lock()
	defer r.mu.Unlock()

	result := []*Version{}
	for _, version := range r.Versions {
		result = append(result, version)	
	}
	return result
}


File: /Users/haruki/golang-mvcc/pkg/mvcc/transaction.go
// 事務邏輯
package mvcc

// Transaction represents a single transaction.
type Transaction struct {
	ID      int // Transaction ID
	ReadTS  int // Read timestamp
	WriteTS int // Write timestamp
}


File: /Users/haruki/golang-mvcc/pkg/utils/helpers.go


File: /Users/haruki/golang-mvcc/tests/concurrency_test.go


File: /Users/haruki/golang-mvcc/tests/isolation_test.go


File: /Users/haruki/golang-mvcc/tests/mvcc_test.go
package mvcc_test

import (
	"fmt"
	"runtime"
	"sync"
	"testing"
	"time"

	"github.com/Mahopanda/golang-mvcc/pkg/mvcc"
	"github.com/stretchr/testify/assert"
)

// 測試基礎功能：事務的寫入與讀取
func TestBasicTransaction(t *testing.T) {
	db := mvcc.NewDatabase()

	// 開始一個事務，寫入一筆資料
	tx1 := db.Begin()
	db.Write(tx1, "key1", "value1")

	// 驗證是否能成功讀取寫入的資料
	value, err := db.Read(tx1, "key1")
	if err != nil || value != "value1" {
		t.Errorf("基礎測試失敗: 預期值 'value1', 實際值 '%s'", value)
	}
}

// 測試隔離級別：Read Uncommitted
func TestReadUncommitted(t *testing.T) {
	db := mvcc.NewDatabase()

	// 事務 1 寫入資料
	tx1 := db.Begin()
	db.Write(tx1, "key1", "value1")

	// 事務 2 嘗試讀取未提交的資料
	tx2 := db.Begin()
	value, err := db.ReadWithIsolation(tx2, "key1", mvcc.ReadUncommitted)
	if err != nil || value != "value1" {
		t.Errorf("Read Uncommitted 測試失敗: 預期值 'value1', 實際值 '%s'", value)
	}
}

// 測試隔離級別：Read Committed
func TestReadCommitted(t *testing.T) {
	db := mvcc.NewDatabase()

	// 事務 1 寫入資料
	tx1 := db.Begin()
	db.Write(tx1, "key1", "value1")

	// 事務 2 嘗試讀取，應該無法讀取未提交的資料
	tx2 := db.Begin()
	value, err := db.ReadWithIsolation(tx2, "key1", mvcc.ReadCommitted)
	if err == nil && value != "" {
		t.Errorf("Read Committed 測試失敗: 未提交的資料不應該可見")
	}

	// 提交事務 1，然後事務 2 再次讀取
	db.Commit(tx1)
	value, err = db.ReadWithIsolation(tx2, "key1", mvcc.ReadCommitted)
	if err != nil || value != "value1" {
		t.Errorf("Read Committed 測試失敗: 預期值 'value1', 實際值 '%s'", value)
	}
}

// 測試隔離級別：Repeatable Read
func TestRepeatableRead(t *testing.T) {
	db := mvcc.NewDatabase()

	// 事務 1 寫入資料並提交
	tx1 := db.Begin()
	db.Write(tx1, "key1", "value1")
	db.Commit(tx1)

	// 事務 2 開始，讀取快照
	tx2 := db.Begin()
	value, err := db.ReadWithIsolation(tx2, "key1", mvcc.RepeatableRead)
	if err != nil || value != "value1" {
		t.Errorf("Repeatable Read 測試失敗: 預期值 'value1', 實際值 '%s'", value)
	}

	// 事務 3 修改資料
	tx3 := db.Begin()
	db.Write(tx3, "key1", "value2")
	db.Commit(tx3)

	// 事務 2 再次讀取，應該仍然看到舊快照
	value, err = db.ReadWithIsolation(tx2, "key1", mvcc.RepeatableRead)
	if err != nil || value != "value1" {
		t.Errorf("Repeatable Read 測試失敗: 預期值 'value1', 實際值 '%s'", value)
	}
}

// 測試多事務的並發寫入
func TestConcurrentTransactions(t *testing.T) {
	db := mvcc.NewDatabase()
	var wg sync.WaitGroup

	wg.Add(2)

	// 事務 1 寫入資料
	go func() {
		defer wg.Done()
		tx := db.Begin()
		db.Write(tx, "key1", "value1")
		db.Commit(tx)
	}()

	// 事務 2 寫入資料
	go func() {
		defer wg.Done()
		tx := db.Begin()
		db.Write(tx, "key1", "value2")
		db.Commit(tx)
	}()

	wg.Wait()

	// 驗證資料是否有其中一個寫入
	tx := db.Begin()
	value, err := db.Read(tx, "key1")
	if err != nil || (value != "value1" && value != "value2") {
		t.Errorf("並發事務測試失敗: 實際值 '%s'", value)
	}
}

// 測試垃圾回收
func TestGarbageCollection(t *testing.T) {
	runtime.GOMAXPROCS(1) // 強制單執行緒執行
	db := mvcc.NewDatabase()

	t.Log("開始寫入第一個版本")
	tx1 := db.Begin()
	db.Write(tx1, "key1", "value1")
	db.Commit(tx1)

	t.Log("模擬時間推進 5")
	db.AdvanceTime(5)

	t.Log("寫入第二個版本")
	tx2 := db.Begin()
	db.Write(tx2, "key1", "value2")
	db.Commit(tx2)

	t.Log("模擬時間推進 6 到垃圾回收門檻後")
	db.AdvanceTime(6)

	t.Log("執行垃圾回收")
	db.CleanupOldVersions()

	record := db.GetData()["key1"]
	t.Log("檢查版本數量")
	if len(record.GetVersions()) != 1 {
		t.Errorf("垃圾回收測試失敗: 應該只保留 1 個版本，但實際保留 %d 個", len(record.GetVersions()))
	}

	// 確認保留的版本是最新版本
	latestVersion := record.GetVersions()[0]
	if latestVersion.Value != "value2" {
		t.Errorf("垃圾回收測試失敗: 最新版本應該是 'value2', 但實際是 '%s'", latestVersion.Value)
	}

	// 確認保留版本的 Timestamp
	if latestVersion.Timestamp != 7 {
		t.Errorf("垃圾回收測試失敗: 最新版本的 Timestamp 應該是 7, 但實際是 %d", latestVersion.Timestamp)
	}

	// 確認舊版本的 EndTS 被正確設置
	if len(record.GetVersions()) > 1 && record.GetVersions()[0].EndTS != 7 {
		t.Errorf("垃圾回收測試失敗: 舊版本的 EndTS 應該是 7, 但實際是 %d", record.GetVersions()[0].EndTS)
	}
}

func TestMVCC(t *testing.T) {
	db := mvcc.NewDatabase()

	// 測試基本寫入和讀取
	tx1 := db.Begin()
	err := db.Write(tx1, "key1", "value1")
	assert.NoError(t, err)

	// 測試未提交讀取
	tx2 := db.Begin()
	val, err := db.ReadWithIsolation(tx2, "key1", mvcc.ReadUncommitted)
	assert.NoError(t, err)
	assert.Equal(t, "value1", val)

	// 測試提交後讀取
	err = db.Commit(tx1)
	assert.NoError(t, err)

	tx3 := db.Begin()
	val, err = db.ReadWithIsolation(tx3, "key1", mvcc.ReadCommitted)
	assert.NoError(t, err)
	assert.Equal(t, "value1", val)

	// 測試垃圾回收
	db.CleanupOldVersions()
	record := db.GetData()["key1"]
	assert.Equal(t, 1, len(record.GetVersions()))
}

// 測試事務回滾
func TestTransactionRollback(t *testing.T) {
	db := mvcc.NewDatabase()
	
	// 寫入初始數據
	tx1 := db.Begin()
	err := db.Write(tx1, "key1", "initial")
	assert.NoError(t, err)
	err = db.Commit(tx1)
	assert.NoError(t, err)
	
	// 開始新事務並寫入
	tx2 := db.Begin()
	err = db.Write(tx2, "key1", "modified")
	assert.NoError(t, err)
	
	// 讀取未提交的修改
	val, err := db.ReadWithIsolation(tx2, "key1", mvcc.ReadUncommitted)
	assert.NoError(t, err)
	assert.Equal(t, "modified", val)
	
	// 回滾事務
	err = db.Rollback(tx2)
	assert.NoError(t, err)
	
	// 驗證數據恢復到初始狀態
	tx3 := db.Begin()
	val, err = db.Read(tx3, "key1")
	assert.NoError(t, err)
	assert.Equal(t, "initial", val)
}

// 測試並發讀寫衝突
func TestConcurrentReadWriteConflict(t *testing.T) {
	db := mvcc.NewDatabase()
	var wg sync.WaitGroup
	
	// 初始化數據
	tx1 := db.Begin()
	db.Write(tx1, "key1", "initial")
	db.Commit(tx1)
	
	wg.Add(2)
	
	// 事務1：讀取後修改
	go func() {
		defer wg.Done()
		tx := db.Begin()
		val, err := db.ReadWithIsolation(tx, "key1", mvcc.RepeatableRead)
		assert.NoError(t, err)
		assert.Equal(t, "initial", val)
		
		// 模擬處理時間
		time.Sleep(100 * time.Millisecond)
		
		err = db.Write(tx, "key1", "modified1")
		assert.NoError(t, err)
		err = db.Commit(tx)
		assert.NoError(t, err)
	}()
	
	// 事務2：並發修改
	go func() {
		defer wg.Done()
		time.Sleep(50 * time.Millisecond) // 確保在事務1讀取後開始
		
		tx := db.Begin()
		err := db.Write(tx, "key1", "modified2")
		assert.NoError(t, err)
		err = db.Commit(tx)
		assert.NoError(t, err)
	}()
	
	wg.Wait()
	
	// 驗證最終結果
	tx := db.Begin()
	val, err := db.Read(tx, "key1")
	assert.NoError(t, err)
	// 根據時間戳，應該是後提交的事務結果
	assert.Equal(t, "modified1", val)
}

// 測試版本鏈完整性
func TestVersionChainIntegrity(t *testing.T) {
	db := mvcc.NewDatabase()
	
	// 創建多個版本
	versions := []string{"v1", "v2", "v3"}
	var lastTx *mvcc.Transaction
	
	for _, v := range versions {
		tx := db.Begin()
		err := db.Write(tx, "key1", v)
		assert.NoError(t, err)
		err = db.Commit(tx)
		assert.NoError(t, err)
		lastTx = tx
	}
	
	// 檢查版本鏈
	record := db.GetData()["key1"]
	allVersions := record.GetVersions()
	assert.Equal(t, len(versions), len(allVersions))
	
	// 驗證時間戳遞增
	for i := 1; i < len(allVersions); i++ {
		assert.True(t, allVersions[i].Timestamp > allVersions[i-1].Timestamp)
	}
	
	// 驗證EndTS設置正確
	for i := 0; i < len(allVersions)-1; i++ {
		assert.Equal(t, allVersions[i+1].Timestamp, allVersions[i].EndTS)
	}
	
	// 驗證最後一個版本的EndTS為0
	assert.Equal(t, 0, allVersions[len(allVersions)-1].EndTS)
}

// 測試大量並發事務
func TestHighConcurrency(t *testing.T) {
	db := mvcc.NewDatabase()
	numGoroutines := 100
	var wg sync.WaitGroup
	wg.Add(numGoroutines)
	
	// 並發執行多個事務
	for i := 0; i < numGoroutines; i++ {
		go func(id int) {
			defer wg.Done()
			
			tx := db.Begin()
			key := fmt.Sprintf("key%d", id%10) // 使用10個不同的key
			value := fmt.Sprintf("value%d", id)
			
			err := db.Write(tx, key, value)
			assert.NoError(t, err)
			
			err = db.Commit(tx)
			assert.NoError(t, err)
		}(i)
	}
	
	wg.Wait()
	
	// 驗證數據一致性
	for i := 0; i < 10; i++ {
		key := fmt.Sprintf("key%d", i)
		tx := db.Begin()
		_, err := db.Read(tx, key)
		assert.NoError(t, err)
	}
}


